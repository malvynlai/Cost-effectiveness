from concurrent.futures import ProcessPoolExecutor, as_completed
import pandas as pd
import numpy as np
import os
import uuid
from tqdm import tqdm
from Visualizations.sensFinal import tornado
import multiprocessing
import completeSimulationv2_ver as run
import xlwings as xw
from shutil import copyfile
import math
import copy



original_file = "/sailhome/malvlai/Cost-effectiveness/Inputs/Inputs_CEA_v4_3.27.25.xlsx"
output_base = "/sailhome/malvlai/Cost-effectiveness/Results/One Way Sensitivity/Data"

input_dict = {
    'cirrhosisUnderdiagnosisRateInMasld_Rate': 0.059,
    'cirrhosisUnderdiagnosisRateInMasld_MasldToHccForUD': 0.043,
    'cirrhosisUnderdiagnosisRateInMasld_MasldToHccNonCirrhotic': 0.0011,
    'masldIncidenceRates_falsePositiveHCC': 0.1,
    'masldIncidenceRates_masldToCirrhosis': 0.006
}

HCC = np.array([0.457, 0.23, 0.313])


# -2, -1
prob_sensitivities = {
    (16, 1): [.242, .181, .302], 
    (63, 4): [.60, .45, .75], 
    (13, 1): [.01085, .00665, .01506],
    (18, 1): [.0004, .00004, .0006],
    (17, 1): [.0225, .0208, .0243],
    (11, 1): [.15, .07, .27],
    (20, 1): [.00175, .00058, .00291], 
    (19, 1): [.017, .013, .021],
    (23, 2): [.533, .39975, .66625], 
    (39, 2): [.201, .15075, .25125],
    (53, 2): [.357, .268, .446],
    (26, 2): [.533, .39975, .66625], 
    (42, 2): [.369, .27675, .46125],
    (55, 2): [.632, .474, .790],
    (29, 2): [.389, .29175, .48625],
    (45, 2): [.792, .594, .990], 
    (57, 2): [.872, .654, 1], 
}


cost_sensitivities = {
    (21, 2): [363, 272, 454],
    (22, 2): [630, 473, 788], 
    (23, 2): [1050, 788, 1313],
    (0, 1): [4395, 3296, 5494], 
    (13, 1): [63255, 33875, 117193], 
    (16, 1): [47151, 43451, 50843], 
    (14, 1): [118753, 54307, 211436], 
    (17, 1): [51961, 44479, 60593],
    (15, 1): [105595, 45639, 144868], 
    (18, 1): [78547, 68621, 91278]
}


util_sensitivities = {
    (25, 2): [.85, .640, 1.0], 
    (10, 3): [.72, .62, .89], 
    (11, 3): [.69, .62, .82], 
    (12, 3): [.53, .2, .78],
}


prob_names = {
    (16, 1): "Proportion with undiagnosed cirrhosis",
    (63, 4): "Screening adherence rate",
    (13, 1): "Non-cirrhotic MASLD to cirrhosis (censored)",
    (18, 1): "Non-cirrhotic MASLD to HCC",
    (17, 1): "(Undiagnosed) cirrhosis with MASLD to HCC",
    (11, 1): "(undiagnosed cirrhosis) to false",
    (20, 1): "Non-cirrhotic MASLD to death",
    (19, 1): "(Undiagnosed) cirrhosis with MASLD to death",
    (23, 2): "Early-stage HCC to treatment",
    (39, 2): "Treated early-stage HCC to death",
    (53, 2): "Untreated early-stage HCC to death",
    (26, 2): "Intermediate-stage HCC to treatment",
    (42, 2): "Treated intermediate-stage HCC to death",
    (55, 2): "Untreated intermediate-stage HCC to death",
    (29, 2): "Late-stage HCC to treatment",
    (45, 2): "Treated late-stage HCC to death",
    (57, 2): "Untreated late-stage HCC to death"
}


cost_names = {
    (21, 2): "Semiannual US and AFP screening",
    (22, 2): "CT/MRI to confirm HCC diagnosis",
    (23, 2): "Repeat CT/MRI for false positive HCC",
    (0, 1): "Medical care of patients with MASLD (non-cirrhotic or with undiagnosed cirrhosis)",
    (13, 1): "Early stage HCC (annual costs) - Treated",
    (16, 1): "Early stage HCC (annual costs) - Untreated",
    (14, 1): "Intermediate stage HCC (annual costs) - Treated",
    (17, 1): "Intermediate stage HCC (annual costs) - Untreated",
    (15, 1): "Late stage HCC (annual costs) - Treated",
    (18, 1): "Late stage HCC (annual costs) - Untreated"
}


util_names = {
    (25, 2): "MASLD without cirrhosis",
    (10, 3): "Early stage HCC",
    (11, 3): "Intermediate stage HCC",
    (12, 3): "Late stage HCC"
}

def check_reading_sheets(sheets):
    """
    Systematically checks all probability variables by comparing the reading sheet
    generated by build_reading_sheet with the one in the Excel file.
    
    Args:
        sheets: Dictionary of pandas DataFrames containing the Excel sheets
        
    Returns:
        Dictionary with comparison results for all probability variables
    """
    import xlwings as xw
    import numpy as np
    import os
    import uuid
    from shutil import copyfile
    
    all_results = {}
    
    # Loop through all probability variables
    for loc, value_range in prob_sensitivities.items():
        param_name = prob_names[loc]
        mean, lower, upper = value_range
        
        # Create a temporary copy of the original file
        temp_file = f"/tmp/{uuid.uuid4()}.xlsx"
        copyfile(original_file, temp_file)
        
        # Use the mean value for testing
        sample_val = mean
        
        print(f"Testing parameter: {param_name} at location {loc} with value {sample_val:.6f}")
        
        # Update the Excel file using xlwings
        app = xw.App(visible=False)
        wb = app.books.open(temp_file)
        sheet = wb.sheets['FinalTransition-Control']
        sheet.cells(loc[0], loc[1]).value = sample_val
        wb.app.calculation = 'automatic'
        wb.app.calculate()
        wb.save()
        wb.close()
        app.quit()
        
        updated_sheets = pd.read_excel(temp_file, sheet_name=None)
        programmatic_reading_sheet = build_reading_sheet(updated_sheets)
        excel_reading_sheet = updated_sheets['ReadingSheet']
        
        comparison_results = {
            'parameter': param_name,
            'location': loc,
            'value': sample_val,
            'differences': {}
        }
        
        key_cells = [
            (0, 1), (0, 2), (0, 5), (0, 6), (0, 7),  # MASLD row
            (1, 3), (1, 4),  # HCC row
            (2, 3), (2, 6),  # Treatment row
            (3, 4), (3, 6),  # Treated row
            (4, 1), (4, 2), (4, 5), (4, 6), (4, 7)   # False Positive HCC row
        ]
        
        for row, col in key_cells:
            programmatic_val = programmatic_reading_sheet.iloc[row, col]
            excel_val = excel_reading_sheet.iloc[row, col]
            
            if not np.isclose(programmatic_val, excel_val, rtol=1e-5, atol=1e-5):
                comparison_results['differences'][(row, col)] = {
                    'programmatic': programmatic_val,
                    'excel': excel_val,
                    'difference': programmatic_val - excel_val
                }
        
        # Clean up
        os.remove(temp_file)
        
        # Store results for this parameter
        all_results[loc] = comparison_results
    
    return all_results


# 0 - 6, 1 - 7, (-2, -1) ie B12 == 10, 1
def build_reading_sheet(sheets):
    final_transition = sheets['FinalTransition-Control']
    final_rewards = sheets['FinalRewards']
    intervention_transition = sheets['FinalTransition-Intervention']
    df = sheets['ReadingSheet']

    # Downstream equations for control transition matrix
    final_transition.iloc[10, 1] = final_transition.iloc[16, 1] * final_transition.iloc[17, 1] + (1 - final_transition.iloc[16, 1]) * final_transition.iloc[18, 1] # Checked, completed
    final_transition.iloc[12, 1] = final_transition.iloc[16, 1] * final_transition.iloc[19, 1] + (1 - final_transition.iloc[16, 1]) * final_transition.iloc[20, 1] # Checked, completed
    # Below 6 eq are for HCC outcome rates
    final_transition.iloc[23, 2] = final_transition.iloc[82, 2] * (1 - final_transition.iloc[16, 1]) + final_transition.iloc[82, 3] * final_transition.iloc[16, 1] if math.isclose(final_transition.iloc[23, 2], .5327) else final_transition.iloc[23, 2] # Checked, completed
    final_transition.iloc[25, 2] = 1 - final_transition.iloc[23, 2] # Checked, completed
    final_transition.iloc[26, 2] = final_transition.iloc[91, 2] * (1 - final_transition.iloc[16, 1]) + final_transition.iloc[91, 3] * final_transition.iloc[16, 1] if math.isclose(final_transition.iloc[26, 2], .5332) else final_transition.iloc[26, 2] # Checked, completed
    final_transition.iloc[28, 2] = 1 - final_transition.iloc[26, 2] # Checked, completed
    final_transition.iloc[29, 2] = final_transition.iloc[98, 2] * (1 - final_transition.iloc[16, 1]) + final_transition.iloc[98, 3] * final_transition.iloc[16, 1] if math.isclose(final_transition.iloc[29, 2], .3886) else final_transition.iloc[29, 2] # Checked, completed
    final_transition.iloc[31, 2] = 1 - final_transition.iloc[29, 2] # Checked, completed
    final_transition.iloc[32, 2] = final_transition.iloc[23, 2] * final_transition.iloc[63, 1] + final_transition.iloc[26, 2] * final_transition.iloc[64, 1] + final_transition.iloc[29, 2] * final_transition.iloc[65, 1] # Checked, completed
    
    # Control transition matrix (MASLD + HCC)
    df.iloc[0, 2] = final_transition.iloc[10, 1] # Checked, completed 
    df.iloc[0, 5] = final_transition.iloc[11, 1] * final_transition.iloc[63, 4] # Checked, completed
    df.iloc[0, 6] = final_transition.iloc[12, 1] # Checked, completed
    df.iloc[0, 7] = final_transition.iloc[13, 1] # Checked, completed
    df.iloc[0, 1] = 1 - df.iloc[0, 2] - df.iloc[0, 5] - df.iloc[0, 6] - df.iloc[0, 7] # Checked, completed
    df.iloc[1, 4] = final_transition.iloc[32, 2] # Checked, completed
    df.iloc[1, 3] = 1 - df.iloc[1, 4] # Checked, completed
    # Downstream equations for control matrix 
    final_transition.iloc[69, 1] = (final_transition.iloc[25, 2] * final_transition.iloc[63, 1]) / (final_transition.iloc[25, 2] * final_transition.iloc[63, 1] + final_transition.iloc[28, 2] * final_transition.iloc[64, 1] + final_transition.iloc[31, 2] * final_transition.iloc[65, 1]) # Checked, completed
    final_transition.iloc[70, 1] = (final_transition.iloc[28, 2] * final_transition.iloc[64, 1]) / (final_transition.iloc[25, 2] * final_transition.iloc[63, 1] + final_transition.iloc[28, 2] * final_transition.iloc[64, 1] + final_transition.iloc[31, 2] * final_transition.iloc[65, 1]) # Checked, completed
    final_transition.iloc[71, 1] = (final_transition.iloc[31, 2] * final_transition.iloc[65, 1]) / (final_transition.iloc[25, 2] * final_transition.iloc[63, 1] + final_transition.iloc[28, 2] * final_transition.iloc[64, 1] + final_transition.iloc[31, 2] * final_transition.iloc[65, 1]) # Checked, completed
    final_transition.iloc[66, 1] = (final_transition.iloc[23, 2] * final_transition.iloc[63, 1]) / (final_transition.iloc[23, 2] * final_transition.iloc[63, 1] + final_transition.iloc[26, 2] * final_transition.iloc[64, 1] + final_transition.iloc[29, 2] * final_transition.iloc[65, 1]) # Checked, completed
    final_transition.iloc[67, 1] = (final_transition.iloc[26, 2] * final_transition.iloc[64, 1]) / (final_transition.iloc[23, 2] * final_transition.iloc[63, 1] + final_transition.iloc[26, 2] * final_transition.iloc[64, 1] + final_transition.iloc[29, 2] * final_transition.iloc[65, 1]) # Checked, completed
    final_transition.iloc[68, 1] = (final_transition.iloc[29, 2] * final_transition.iloc[65, 1]) / (final_transition.iloc[23, 2] * final_transition.iloc[63, 1] + final_transition.iloc[26, 2] * final_transition.iloc[64, 1] + final_transition.iloc[29, 2] * final_transition.iloc[65, 1]) # Checked, completed
    # Untreated outcome rates (53, 55, 57) are varied, so we need to make sure they sum to 1
    final_transition.iloc[52, 2] = 1 - final_transition.iloc[53, 2] # Checked, completed
    final_transition.iloc[54, 2] = 1 - final_transition.iloc[55, 2] # Checked, completed
    final_transition.iloc[56, 2] = 1 - final_transition.iloc[57, 2] # Checked, completed
    # Treated outcome rates (39, 42, 45) are varied, so we need to make sure they sum to 1
    final_transition.iloc[38, 2] = 1 - final_transition.iloc[39, 2] # Checked, completed
    final_transition.iloc[41, 2] = 1 - final_transition.iloc[42, 2] # Checked, completed
    final_transition.iloc[44, 2] = 1 - final_transition.iloc[45, 2] # Checked, completed
    # These are the final 4 eq before the transition matrix
    final_transition.iloc[58, 2] = final_transition.iloc[52, 2] * final_transition.iloc[69, 1] + final_transition.iloc[54, 2] * final_transition.iloc[70, 1] + final_transition.iloc[56, 2] * final_transition.iloc[71, 1] # Checked, completed
    final_transition.iloc[59, 2] = final_transition.iloc[53, 2] * final_transition.iloc[69, 1] + final_transition.iloc[55, 2] * final_transition.iloc[70, 1] + final_transition.iloc[57, 2] * final_transition.iloc[71, 1] # Checked, completed
    final_transition.iloc[47, 2] = final_transition.iloc[38, 2] * final_transition.iloc[66, 1] + final_transition.iloc[41, 2] * final_transition.iloc[67, 1] + final_transition.iloc[44, 2] * final_transition.iloc[68, 1] # Checked, completed 
    final_transition.iloc[48, 2] = final_transition.iloc[39, 2] * final_transition.iloc[66, 1] + final_transition.iloc[42, 2] * final_transition.iloc[67, 1] + final_transition.iloc[45, 2] * final_transition.iloc[68, 1] # Checked, completed
    # Treated/Untreated/False Positive
    df.iloc[2, 3] = final_transition.iloc[58, 2] # Checked, completed
    df.iloc[2, 6] = final_transition.iloc[59, 2] # Checked, completed 
    df.iloc[3, 4] = final_transition.iloc[47, 2] # Checked, completed
    df.iloc[3, 6] = final_transition.iloc[48, 2] # Checked, completed
    df.iloc[4, 2] = df.iloc[0, 2] # Checked, completed 
    df.iloc[4, 5] = 0 # Checked, completed
    df.iloc[4, 6] = df.iloc[0, 6] # Checked, completed
    df.iloc[4, 7] = df.iloc[0, 7] # Checked, completed
    df.iloc[4, 1] = 1 - df.iloc[4, 2] - df.iloc[4, 5] - df.iloc[4, 6] - df.iloc[4, 7] # Checked, completed





    # Downstream equation for intervention transition matrix
    final_transition.iloc[63, 2] = final_transition.iloc[63, 3] * final_transition.iloc[63, 4] + final_transition.iloc[63, 1] * (1 - final_transition.iloc[63, 4])
    final_transition.iloc[64, 2] = final_transition.iloc[64, 3] * final_transition.iloc[63, 4] + final_transition.iloc[64, 1] * (1 - final_transition.iloc[63, 4])
    final_transition.iloc[65, 2] = final_transition.iloc[65, 3] * final_transition.iloc[63, 4] + final_transition.iloc[65, 1] * (1 - final_transition.iloc[63, 4])
    final_transition.iloc[32, 3] = final_transition.iloc[23, 2] * final_transition.iloc[63, 2] + final_transition.iloc[26, 2] * final_transition.iloc[64, 2] + final_transition.iloc[29, 2] * final_transition.iloc[65, 2] # Checked, completed
    # Intervention transition matrix - many of them reference final_transition (control) since the intervention has
    # the same row/values
    intervention_transition.iloc[0, 2] = final_transition.iloc[10, 1] # Checked, completed
    intervention_transition.iloc[0, 5] = final_transition.iloc[11, 1] * final_transition.iloc[63, 4] # Checked, completed
    intervention_transition.iloc[0, 6] = final_transition.iloc[12, 1] # Checked, completed
    intervention_transition.iloc[0, 7] = final_transition.iloc[13, 1] # Checked, completed
    intervention_transition.iloc[0, 1] = 1 - intervention_transition.iloc[0, 2] - intervention_transition.iloc[0, 5] - intervention_transition.iloc[0, 6] - intervention_transition.iloc[0, 7] # Checked, completed
    intervention_transition.iloc[1, 4] = final_transition.iloc[32, 3] # Checked, completed
    intervention_transition.iloc[1, 3] = 1 - intervention_transition.iloc[1, 4] # Checked, completed
    # Downstream equations for intervention
    final_transition.iloc[69, 2] = (final_transition.iloc[25, 3] * final_transition.iloc[63, 2]) / (final_transition.iloc[25, 3] * final_transition.iloc[63, 2] + final_transition.iloc[28, 3] * final_transition.iloc[64, 2] + final_transition.iloc[31, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[70, 2] = (final_transition.iloc[28, 3] * final_transition.iloc[64, 2]) / (final_transition.iloc[25, 3] * final_transition.iloc[63, 2] + final_transition.iloc[28, 3] * final_transition.iloc[64, 2] + final_transition.iloc[31, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[71, 2] = (final_transition.iloc[31, 3] * final_transition.iloc[65, 2]) / (final_transition.iloc[25, 3] * final_transition.iloc[63, 2] + final_transition.iloc[28, 3] * final_transition.iloc[64, 2] + final_transition.iloc[31, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[66, 2] = (final_transition.iloc[23, 3] * final_transition.iloc[63, 2]) / (final_transition.iloc[23, 3] * final_transition.iloc[63, 2] + final_transition.iloc[26, 3] * final_transition.iloc[64, 2] + final_transition.iloc[29, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[67, 2] = (final_transition.iloc[26, 3] * final_transition.iloc[64, 2]) / (final_transition.iloc[23, 3] * final_transition.iloc[63, 2] + final_transition.iloc[26, 3] * final_transition.iloc[64, 2] + final_transition.iloc[29, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[68, 2] = (final_transition.iloc[29, 3] * final_transition.iloc[65, 2]) / (final_transition.iloc[23, 3] * final_transition.iloc[63, 2] + final_transition.iloc[26, 3] * final_transition.iloc[64, 2] + final_transition.iloc[29, 3] * final_transition.iloc[65, 2]) # Checked, completed
    final_transition.iloc[58, 3] = final_transition.iloc[52, 2] * final_transition.iloc[69, 2] + final_transition.iloc[54, 2] * final_transition.iloc[70, 2] + final_transition.iloc[56, 2] * final_transition.iloc[71, 2] # Checked, completed
    final_transition.iloc[59, 3] = final_transition.iloc[53, 2] * final_transition.iloc[69, 2] + final_transition.iloc[55, 2] * final_transition.iloc[70, 2] + final_transition.iloc[57, 2] * final_transition.iloc[71, 2] # Checked, completed
    final_transition.iloc[47, 3] = final_transition.iloc[38, 2] * final_transition.iloc[66, 2] + final_transition.iloc[41, 2] * final_transition.iloc[67, 2] + final_transition.iloc[44, 2] * final_transition.iloc[68, 2] # Checked, completed
    final_transition.iloc[48, 3] = final_transition.iloc[39, 2] * final_transition.iloc[66, 2] + final_transition.iloc[42, 2] * final_transition.iloc[67, 2] + final_transition.iloc[45, 2] * final_transition.iloc[68, 2] # Checked, completed
    # Treated/Untreated/False Positive (Intervention)
    intervention_transition.iloc[2, 3] = final_transition.iloc[58, 3] # Checked, completed
    intervention_transition.iloc[2, 6] = final_transition.iloc[59, 3] # Checked, completed
    intervention_transition.iloc[3, 4] = final_transition.iloc[47, 3] # Checked, completed
    intervention_transition.iloc[3, 6] = final_transition.iloc[48, 3] # Checked, completed
    intervention_transition.iloc[4, 2] = intervention_transition.iloc[0, 2] # Checked, completed
    intervention_transition.iloc[4, 5] = 0 # Checked, completed
    intervention_transition.iloc[4, 6] = intervention_transition.iloc[0, 6] # Checked, completed
    intervention_transition.iloc[4, 7] = intervention_transition.iloc[0, 7] # Checked, completed
    intervention_transition.iloc[4, 1] = 1 - intervention_transition.iloc[4, 2] - intervention_transition.iloc[4, 5] - intervention_transition.iloc[4, 6] - intervention_transition.iloc[4, 7] # Checked, completed
    
    


    # Control costs, reading sheet
    final_rewards.iloc[1, 1] = final_rewards.iloc[0, 1] + final_rewards.iloc[22, 2] # Checked, completed
    # print("Transition values (66:69, 1):")
    # print(final_transition.iloc[66:69, 1])
    # print("\nRewards values (13:16, 1):")
    # print(final_rewards.iloc[13:16, 1])
    # print("Multiplication result:")
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[66:69, 1]).values
    reward_values = pd.to_numeric(final_rewards.iloc[13:16, 1]).values
    # print(transition_values * reward_values)
    # print("\nSum of multiplication:")
    # print((transition_values * reward_values).sum())
    final_rewards.iloc[2, 1] = (transition_values * reward_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[69:72, 1]).values
    reward_values = pd.to_numeric(final_rewards.iloc[16:19, 1]).values
    final_rewards.iloc[3, 1] = (transition_values * reward_values).sum() # Checked, completed
    
    df.iloc[1, 30] = final_rewards.iloc[1, 1] # Checked, completed
    df.iloc[2, 30] = final_rewards.iloc[2, 1] # Checked, completed
    df.iloc[3, 30] = final_rewards.iloc[3, 1] # Checked, completed




    # Intervention costs, reading sheet
    # Handle single value operations without .values
    final_rewards.iloc[21, 1] = pd.to_numeric(final_rewards.iloc[21, 2]) * pd.to_numeric(final_transition.iloc[63, 4]) # Checked, completed
    final_rewards.iloc[0, 2] = final_rewards.iloc[0, 1] + final_rewards.iloc[21, 1] # Checked, completed
    final_rewards.iloc[1, 2] = final_rewards.iloc[0, 1] + final_rewards.iloc[22, 2] # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[66:69, 2]).values
    reward_values = pd.to_numeric(final_rewards.iloc[13:16, 1]).values
    final_rewards.iloc[2, 2] = (transition_values * reward_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[69:72, 2]).values
    reward_values = pd.to_numeric(final_rewards.iloc[16:19, 1]).values
    final_rewards.iloc[3, 2] = (transition_values * reward_values).sum() # Checked, completed
    
    final_rewards.iloc[4, 2] = final_rewards.iloc[23, 2] + final_rewards.iloc[0, 1] # Checked, completed
    df.iloc[0, 31] = final_rewards.iloc[0, 2] # Checked, completed
    df.iloc[1, 31] = final_rewards.iloc[1, 2] # Checked, completed
    df.iloc[2, 31] = final_rewards.iloc[2, 2] # Checked, completed
    df.iloc[3, 31] = final_rewards.iloc[3, 2] # Checked, completed
    df.iloc[4, 31] = final_rewards.iloc[4, 2] # Checked, completed




    # Control utilities, reading sheet
    # Handle single value operations without .values
    final_rewards.iloc[25, 1] = pd.to_numeric(final_rewards.iloc[26, 2]) * pd.to_numeric(final_transition.iloc[16, 1]) + pd.to_numeric(final_rewards.iloc[25, 2]) * (1 - pd.to_numeric(final_transition.iloc[16, 1])) # Checked, completed
    final_rewards.iloc[0, 3] = final_rewards.iloc[25, 1] # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    reward_values = pd.to_numeric(final_rewards.iloc[10:13, 3]).values
    transition_values = pd.to_numeric(final_transition.iloc[63:66, 1]).values
    final_rewards.iloc[1, 3] = (reward_values * transition_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[66:69, 1]).values
    final_rewards.iloc[2, 3] = (reward_values * transition_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[69:72, 1]).values
    final_rewards.iloc[3, 3] = (reward_values * transition_values).sum() # Checked, completed
    
    final_rewards.iloc[4, 3] = final_rewards.iloc[0, 3] # Checked, completed
    df.iloc[0, 32] = final_rewards.iloc[0, 3] # Checked, completed
    df.iloc[1, 32] = final_rewards.iloc[1, 3] # Checked, completed
    df.iloc[2, 32] = final_rewards.iloc[2, 3] # Checked, completed
    df.iloc[3, 32] = final_rewards.iloc[3, 3] # Checked, completed
    df.iloc[4, 32] = final_rewards.iloc[4, 3] # Checked, completed




    # Intervention utilities, reading sheet
    final_rewards.iloc[0, 4] = final_rewards.iloc[25, 1] # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    reward_values = pd.to_numeric(final_rewards.iloc[10:13, 3]).values
    transition_values = pd.to_numeric(final_transition.iloc[63:66, 2]).values
    final_rewards.iloc[1, 4] = (reward_values * transition_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[66:69, 2]).values
    final_rewards.iloc[2, 4] = (reward_values * transition_values).sum() # Checked, completed
    
    # Convert to numeric and get just the values for Series operations
    transition_values = pd.to_numeric(final_transition.iloc[69:72, 2]).values
    final_rewards.iloc[3, 4] = (reward_values * transition_values).sum() # Checked, completed
    
    # Handle single value operation without .values
    final_rewards.iloc[4, 4] = pd.to_numeric(final_rewards.iloc[0, 4]) * 0.95 # Checked, completed
    df.iloc[0, 33] = final_rewards.iloc[0, 4] # Checked, completed
    df.iloc[1, 33] = final_rewards.iloc[1, 4] # Checked, completed
    df.iloc[2, 33] = final_rewards.iloc[2, 4] # Checked, completed
    df.iloc[3, 33] = final_rewards.iloc[3, 4] # Checked, completed
    df.iloc[4, 33] = final_rewards.iloc[4, 4] # Checked, completed
  
  
    # df = sheets['FinalRewards']
    # for i in range(5): 
    #     for j in range(4):
    #         print(df.iloc[i, 1 + j])
    #     print('\n')
    # print('\n')
    # df = sheets['ReadingSheet']
    # for i in range(5):
    #     for j in range(4):
    #         print(df.iloc[i, 30 + j])
    #     print('\n')
    # sheets['FinalTransition-Control'] = final_transition
    # sheets['FinalTransition-Intervention'] = intervention_transition
    # sheets['FinalRewards'] = final_rewards
    return df


def run_param_group(args):
    loc, value_range, param_type, size = args
    sheets = pd.read_excel(original_file, sheet_name=None)
    mean, lower, upper = value_range

    if param_type == 'prob' or param_type == 'util':
        if not (lower <= mean <= upper):
            raise ValueError(f"Mean {mean} must be between lower {lower} and upper {upper} for param {loc}")
        
        mean_scaled = (mean - lower) / (upper - lower)
        mean_scaled = np.clip(mean_scaled, 1e-6, 1 - 1e-6)
        
        std_scaled = 1 / 3.92
        var_scaled = std_scaled ** 2
        
        alpha = mean_scaled * ((mean_scaled * (1 - mean_scaled)) / var_scaled - 1)
        beta = (1 - mean_scaled) * ((mean_scaled * (1 - mean_scaled)) / var_scaled - 1)
        
        samples = np.random.beta(alpha, beta, size=size)
        samples = lower + samples * (upper - lower)


    elif param_type == 'cost':
        sigma = (upper - lower) / 3.92
        shape = (mean / sigma) ** 2
        scale = sigma ** 2 / mean
        samples = np.random.gamma(shape, scale, size)

    results = []
    for sample_val in samples:
        sheets_copy = {k: copy.deepcopy(v) for k, v in sheets.items()}
        sheet_name = 'FinalTransition-Control' if param_type == 'prob' else 'FinalRewards'
        sheets_copy[sheet_name].iloc[loc[0], loc[1]] = sample_val
        sheets_copy['ReadingSheet'] = build_reading_sheet(sheets_copy)

        # Generate random numbers once for both runs
        rng = np.random.default_rng(42)
        num_chains = 10**4
        num_steps = 100
        random_numbers = rng.random((num_chains, num_steps - 1))

        s, ageVector, ctrl_util, _, ctrl_rew, _ = run.completeRunAge(sheets_copy, input_dict, HCC, intervention=False, random_numbers=random_numbers)
        s, ageVector, int_util, _, int_rew, _ = run.completeRunAge(sheets_copy, input_dict, HCC, intervention=True, random_numbers=random_numbers)

        icer = (np.mean(int_rew) - np.mean(ctrl_rew)) / (np.mean(int_util) - np.mean(ctrl_util))
        nmb = 100000 * (np.mean(int_util) - np.mean(ctrl_util)) - (np.mean(int_rew) - np.mean(ctrl_rew))
        results.append([sample_val, icer, nmb])

    df = pd.DataFrame(results, columns=['Value', 'ICER', 'NMB'])
    out_path = os.path.join(output_base, 
        'Probabilities' if param_type == 'prob' else 
        'Costs' if param_type == 'cost' else 'Utilities', 
        f'{loc}.csv')
    
    print(f"\nSaving results for {param_type} parameter {loc} to: {out_path}")
    print(f"Results shape: {df.shape}")
    
    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        df.to_csv(out_path, index=False)
        print(f"Successfully saved file to {out_path}")
    except Exception as e:
        print(f"Error saving file: {str(e)}")
        raise
    
    return loc


if __name__ == "__main__":
    multiprocessing.set_start_method("spawn", force=True)

    size = 10000
    jobs = []

    for loc, v in prob_sensitivities.items():
        jobs.append((loc, v, 'prob', size))
    for loc, v in cost_sensitivities.items():
        jobs.append((loc, v, 'cost', size))
    for loc, v in util_sensitivities.items():
        jobs.append((loc, v, 'util', size))
    # df = pd.read_excel(original_file, sheet_name='ReadingSheet')
    # for i in range(6):
    #     for j in range(4):
    #         print(df.iloc[i, 30 + j])
        
    # df = pd.read_excel(original_file, sheet_name = 'FinalRewards')
    # for i in range(6): 
    #     for j in range(4):
    #         print(df.iloc[i, 1 + j])
    print(f"Running sensitivity analysis on {len(jobs)} variables with {size} samples each")

    with ProcessPoolExecutor() as executor:
        futures = [executor.submit(run_param_group, job) for job in jobs]
        for future in tqdm(as_completed(futures), total=len(futures), desc="Running variables"):
            try:
                future.result()
            except Exception as e:
                import traceback
                print(f"\n❌ Error in job {future}:")
                traceback.print_exception(type(e), e, e.__traceback__)


    print("Generating tornado plots")
    tornado(os.path.join(output_base, "Probabilities"), 0, original_file)
    tornado(os.path.join(output_base, "Costs"), 1, original_file)
    tornado(os.path.join(output_base, "Utilities"), 2, original_file)
    